#############################################################
#                                                           #
#         Thread readme                                     #
#                                                           #
#############################################################

1thread的状态
A new(新生) new thread() 此时线程还没有运行
B runnable(可运行)  调用start()方法 可运行状态的线程可能在运行也可能没有 取决于操作系统提供的运行时间
C blocked(被阻塞) 调用sleep   i/o上被阻塞  线程枷锁
D dead (死亡)

############################################################
并发与并行




################################################################
             Thread 锁对象 
1 每个对象都有一个隐式的锁
2 获得锁的方式1调用一个同步方法2进入一个同步块（区别？）             
             
调用sleep()和yield()的时候锁并没有被释放，而调用wait()将释放锁。这样另一个任务（线程）可以获得当前对象的锁，从而进入它的synchronized方法中。可以通过notify()/notifyAll()，或者时间到期，从wait()中恢复执行。
只能在同步控制方法或同步块中调用wait()、notify()和notifyAll()。如果在非同步的方法里调用这些方法，在运行时会抛出IllegalMonitorStateException异常。             
             